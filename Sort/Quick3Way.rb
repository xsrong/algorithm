=begin
# 三向切分的快速排序
# 快速排序的升级版，适用于对含有大量重复元素的数组排序
# 基本思路是将数组切分为[比基准值小的] + [等于基准值的] + [大于基准值的]三部分，再递归地对小于和大于的部分进行排序
# 实现方法：
# 使用left, mid, right三个标记，并把进行任何操作之前的数组的首个元素的值作为基准值p。
# 如果arr[mid]小于基准值p，arr[mid]和arr[left]交换，mid和left各加1
# 如果arr[mid]大于基准值p，arr[mid]和arr[right]交换，right减1
# 如果arr[mid]等于基准值p，mid加1
# 如果mid大于right，循环结束，此时数组已经被分为[比基准值小的] + [等于基准值的] + [大于基准值的]三部分，执行递归。

[3, 2, 1, 4, 3, 0, 2, 3, 2, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 3]
 ↑　↑　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　↑
 l  m                                                        r

[2, 3, 1, 4, 3, 0, 2, 3, 2, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 3]
    l  m                                                     r

[2, 1, 3, 4, 3, 0, 2, 3, 2, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 3]
       l  m                                                  r

[2, 1, 3, 3, 3, 0, 2, 3, 2, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 4]
       l  m                                               r

[2, 1, 3, 3, 3, 0, 2, 3, 2, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 4]
       l        m                                         r

[2, 1, 0, 3, 3, 3, 2, 3, 2, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 4]
          l        m                                      r

[2, 1, 0, 2, 3, 3, 3, 3, 2, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 4]
             l        m                                   r

[2, 1, 0, 2, 3, 3, 3, 3, 2, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 4]
             l           m                                r

[2, 1, 0, 2, 2, 3, 3, 3, 3, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 4]
                l           m                             r

[2, 1, 0, 2, 2, 3, 3, 3, 3, 3, 0, 4, 4, 4, 0, 3, 4, 4, 1, 0, 4]
                l              m                          r

[2, 1, 0, 2, 2, 0, 3, 3, 3, 3, 3, 4, 4, 4, 0, 3, 4, 4, 1, 0, 4]
                   l              m                       r

[2, 1, 0, 2, 2, 0, 3, 3, 3, 3, 3, 0, 4, 4, 0, 3, 4, 4, 1, 4, 4]
                   l              m                    r

[2, 1, 0, 2, 2, 0, 0, 3, 3, 3, 3, 3, 4, 4, 0, 3, 4, 4, 1, 4, 4]
                      l              m                 r

[2, 1, 0, 2, 2, 0, 0, 3, 3, 3, 3, 3, 1, 4, 0, 3, 4, 4, 4, 4, 4]
                      l              m              r

[2, 1, 0, 2, 2, 0, 0, 1, 3, 3, 3, 3, 3, 4, 0, 3, 4, 4, 4, 4, 4]
                         l              m           r

[2, 1, 0, 2, 2, 0, 0, 1, 3, 3, 3, 3, 3, 4, 0, 3, 4, 4, 4, 4, 4]
                         l              m        r

[2, 1, 0, 2, 2, 0, 0, 1, 3, 3, 3, 3, 3, 4, 0, 3, 4, 4, 4, 4, 4]
                         l              m     r

[2, 1, 0, 2, 2, 0, 0, 1, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4]
                         l              m  r

[2, 1, 0, 2, 2, 0, 0, 1, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4]
                         l                 mr

[2, 1, 0, 2, 2, 0, 0, 1, 0, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4]
                            l              r  m

之后再对arr[0..l-1]和arr[r+1..arr.length-1]进行递归
=end


class Quick3Way
  class << self
    def sort arr, lo, hi
      return if lo >= hi
      left_mark = lo
      right_mark = hi
      pivot = arr[lo]
      mid_mark = lo + 1
      while mid_mark <= right_mark
        if arr[mid_mark] < pivot
          arr[mid_mark], arr[left_mark] = arr[left_mark], arr[mid_mark]
          mid_mark += 1
          left_mark += 1
        elsif arr[mid_mark] > pivot
          arr[mid_mark], arr[right_mark] = arr[right_mark], arr[mid_mark]
          right_mark -= 1
        else
          mid_mark += 1
        end
      end
      sort arr, lo, left_mark - 1
      sort arr, right_mark + 1, hi
    end
  end
end